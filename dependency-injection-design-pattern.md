---
description: What is Dependency Injection? and Why is this pattern used in this codebase.
---

# Dependency Injection Design Pattern

## Dependency Injection Design Pattern

This codebase is utilizing the [Dependency Injection](https://www.tutorialsteacher.com/ioc/dependency-injection) design pattern for a big portion of overall design methodology. The idea is to keep the code loosely coupled and make the code modular. However, you can write automation code that does not use this pattern perfectly fine. All the examples you will see on the web for test automation will generally NOT be using this design pattern. It is design choice for this codebase, so its important you understand the basics of how it works.

Understanding this pattern, will put you a step or two above the average test automation code writer. To the test automation community its a relativity new concept and most aren't aware of it at all. However, to the developer community its been in use for many years and fits with SOLID principles of code design. Its the D in SOLID. The Pros to leveraging this pattern greatly outweigh the cons, and once you get pass the initial complexity of thinking differently about how things are coded, you'll have a hard time going back to the typical inheritance model most C# test automation codebases are utilizing. 

My advice when learning this pattern, is don't get caught up in the complexities of setup and the big words, instead get the basics down of understanding the advantages of injecting over inheriting provides, and how you can leverage these features for writing better code. The setup is a one time thing done when codebase is started, that you would want to learn if building a custom framework from scratch, or if switching an older codebase to use this pattern. The big words, are just big words, sound scary then they are. In a nutshell the words, such as Dependency Inversion, and Inversion of Control, just mean we no longer want our code to control object creation, instead we setup a container to manage them and now we just inject what we need, providing more isolated smaller blocks of code to work with, very much like the lego system works at a high level. 

You might ask, if no one else is using for test automation, why make it a design choice for this project? This pattern in my opinion, is worth using when you have a larger test automation codebase and especially when you have more then 1 or 2 people working on it. The Test Automation this documentation is for, fits both those descriptions. Most examples, are smaller projects, hence example projects, and setting up for a smaller project might be overkill. 

It is considered a more complex pattern when it comes to setting up a codebase to be able to utilize this pattern. It requires understanding the concepts of containers, what they do, and how they need to be configured. Containers are those sort of things once setup, it should never need to be configured again except to add new sub projects that might get added to your solution. DI as I will refer to it, provides some unique advantages and can make things easier for those writing code in your codebase, without needing to know anything about DI, except the basics, how to inject a dependency and how to structure code. Examples of why it works well with test automation code: 

* It promotes a standard code structure. Using a template style as we do for each type of major code structure used in automation such as a Test, Workflow, or Page Object is structured the same and have been provided as example templates that users simply copy and change the names and build within to quickly get started.
* If you want developers to assist in developing automation code, DI is defacto for most codebases because of the loosely coupled code, and modularity it provides. Your developers will be happy to see a code style they are use to and makes it more easier for them to work with something they are familiar with. 
* The ideal of modularity, really helps with writing re-usable code in smaller pieces, making readability much easier and code easier to digest. You'll appreciate it more when you have to take ownership of code you didn't write.
* Since everything is written to contracts (interfaces), versus to concrete classes, it allows the ability to work on bigger pieces and not upset any code will working on it, and simply switching the contract to inherit your new class while testing it out, is a major big deal. Knowing if you want to add a feature, or change the version of say the web driver to see how well it works with your codebase before full implementation is super important and gives your code extensibility and easier to maintain as well. 
* Increased flexibility, means increased number of ways to solve a problem. This can be seen as an advantage, in that your less limited by your project's overall design as to the code you implement, but at the same time, can be seen as a negative depending of the experience level of coders.

Many more advantages to this design pattern then what is listed here. These are those items that pertain more to test automation code and hopefully give me insight on why choose this over a typical inheritance model for designing code, see composition over inheritance if you want to get in the nitty gritty.

Keep in mind, in this codebase, just because its using DI as the primary for structing code, you will see instances where regular inheritance has been used. Its about the best means for solving different problems. Sometimes inheritance makes better sense, or just happen to be a solution that was re-used from an inheritance based code model. However, its a small portion of the majority of code, and used sparingly. Inheritance, couples code, so where you see a base class that is implemented, all code related to it, now is coupled to that base class. Base classes are nice for just having methods available without any extra effort for those inheriting it, but it requires you dig into that baseclass to know what it provides, and you get everything, even if you are not using it. Versus when injected, you see all the methods it provides with the intellisense and use only what you need from the injected class. 

For example, if Webpage was a base class to all page objects, all those methods get basically added to your page object and to discover what is there you have to know everything about WebPage and how it works, otherwise you won't know what is available to you. New coder comes in, needs to modify WebPage, and sees some methods, they can do better, they remove it, or change it drastically, and now has to go test everything, because they have no insight on how its being used in each class. Now with injecting it, there is a contract, new coder comes in looks at that contract and sees exactly what is there for there use. They can use what is in the contract or ADD their own method to that contract, and use without worrying about breaking other code. Hence the principle, open to extension but not modification becomes very valuable.
